# 第 243 场周赛题解

## Q1 [1880. 检查某单词是否等于两单词之和](https://leetcode-cn.com/problems/check-if-word-equals-summation-of-two-words/)

给定的字符范围保证在$a..j$之间，因此不用考虑大于$10$的情况，直接映射到两个$Int$值即可。

```kotlin
class Solution1880 {
    fun isSumEqual(firstWord: String, secondWord: String, targetWord: String): Boolean {
        val a = firstWord.map { it - 'a' }.joinToString("").toInt()
        val b = secondWord.map { it - 'a' }.joinToString("").toInt()
        val c = targetWord.map { it - 'a' }.joinToString("").toInt()
        return a + b == c
    }
}
```

## Q2 [1881. 插入后的最大值](https://leetcode-cn.com/problems/maximum-value-after-insertion/)

贪心的做法，分两种情况讨论。

1. 第一位是'-'，整体数字是负数，将数字插入到第一个比插入字符大的数字前面
2. 整体数字是正数，将数字插入到第一个比插入字符小的数字前面
3. 若一直没有插入，则将数字插入到最后面即可。

```kotlin
class Solution1881 {
    fun maxValue(n: String, x: Int): String {
        val sb = StringBuilder(n)
        var isNeg = false
        for (i in sb.indices) {
            if (sb[i] == '-') {
                isNeg = true
                continue
            }
            if (isNeg) {
                if (x < sb[i] - '0') {
                    sb.insert(i, x)
                    return sb.toString()
                }
            } else {
                if (x > sb[i] - '0') {
                    sb.insert(i, x)
                    return sb.toString()
                }
            }
        }
        return sb.append(x).toString()
    }
}
```

## Q3 [1882. 使用服务器处理任务](https://leetcode-cn.com/problems/process-tasks-using-servers/)

比赛时被卡常卡死了，需要增加一个时间优化让队列中的内容提前出队，否则后续的入队操作会较为耗时。

分别用两个优先级队列记录当前正在执行任务的服务器和等待执行任务的服务器。需要注意的是

```kotlin
class Solution5774 {
    fun assignTasks(servers: IntArray, tasks: IntArray): IntArray {
        val ready = PriorityQueue<Triple<Int, Int, Int>>(compareBy({ it.first }, { it.second }))
        for (i in servers.indices) {
            ready.offer(Triple(servers[i], i, 0))
        }
        val doing = PriorityQueue<Triple<Int, Int, Int>>(compareBy({ it.third }, { it.first }, { it.second }))
        val ans = ArrayList<Int>()
        var ts = 0
        for (i in tasks.indices) {
            // 记录当前已到达的时间
            ts = maxOf(ts, i)
            // 能出队的尽量都出队
            while (doing.isNotEmpty() && doing.peek().third <= ts) {
                val it = doing.poll()
                ready.offer(Triple(it.first, it.second, 0))
            }
            val item = ready.poll() ?: doing.poll()
            ans.add(item.second)
            if (item.third != 0) {
                ts = item.third
            }
            doing.offer(Triple(item.first, item.second, ts + tasks[i]))
        }
        return ans.toIntArray()
    }
}
```

## Q4 [1872. 石子游戏 VIII](https://leetcode-cn.com/problems/stone-game-viii/)

首先分析题目，A、B拿的其实都是前缀和，且拿的$index$从$1$开始且每次都不一样。若一次拿全，则是完整和。记$f[i]$为从$i$开始拿的最优值，则拿$i$位结果$pre[i] - f[i + 1]$，不拿$i$位为$f[i + 1]$。逆序获取至$f[1]$即可。

```kotlin
class Solution1872 {
    fun stoneGameVIII(stones: IntArray): Int {
        val n = stones.size
        val pre = stones.preSumArray().takeLast(n).map { it.toInt() }
        val f = IntArray(n)
        f[n - 1] = pre[n - 1]
        for (i in n - 2 downTo 0) {
            f[i] = maxOf(f[i + 1], pre[i] - f[i + 1])
        }
        return f[1]
    }
}

fun IntArray.preSumArray(): LongArray {
    val preSum = LongArray(this.size + 1)
    for (i in this.indices) {
        preSum[i + 1] = preSum[i] + this[i]
    }
    return preSum
}
```



